/**
 * Copy files.
 * @function filecopy
 * @param {string} src - Source file to copy from.
 * @param {string} dest - Destination file path.
 * @param {object} [options] - Optional settings.
 * @param {boolean} [options.mkdirp] - Make parent directory if needed.
 * @param {string} [options.mode] - File permission.
 * @returns {Promise}
 */

'use strict';

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var argx = require('argx');
var fs = require('fs');
var path = require('path');
var aglob = require('aglob');

var _require = require('asfs');

var mkdirpAsync = _require.mkdirpAsync;

var fileSize = require('./filing/file_size');
var singleCopy = require('./filing/single_copy');
var isExistingDir = require('./filing/is_existing_dir');
var co = require('co');

/** @lends filecopy */
function filecopy(src, dest, options) {
  var args = argx(arguments);
  if (args.pop('function')) {
    throw new Error('Callback is no more supported. Use promise interface.');
  }
  options = args.pop('object') || {};
  dest = args.pop('string');

  return co(_regenerator2.default.mark(function _callee() {
    var _this = this;

    var _options, mode, destIsDir, results, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _loop, _iterator, _step, changed;

    return _regenerator2.default.wrap(function _callee$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (dest) {
              _context2.next = 2;
              break;
            }

            throw new Error('dest is required.');

          case 2:
            _options = options;
            mode = _options.mode;
            _context2.next = 6;
            return aglob(src);

          case 6:
            src = _context2.sent;
            _context2.next = 9;
            return isExistingDir(dest);

          case 9:
            destIsDir = _context2.sent;
            results = [];
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _iteratorError = undefined;
            _context2.prev = 14;
            _loop = _regenerator2.default.mark(function _loop() {
              var aSrc, srcFilename, destFilename, beforeSize, afterSize;
              return _regenerator2.default.wrap(function _loop$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      aSrc = _step.value;
                      srcFilename = path.resolve(aSrc);
                      destFilename = destIsDir ? path.join(dest, path.basename(aSrc)) : path.resolve(dest);

                      if (!options.mkdirp) {
                        _context.next = 6;
                        break;
                      }

                      _context.next = 6;
                      return mkdirpAsync(path.dirname(destFilename));

                    case 6:
                      _context.next = 8;
                      return fileSize(destFilename);

                    case 8:
                      beforeSize = _context.sent;
                      _context.next = 11;
                      return singleCopy(srcFilename, destFilename);

                    case 11:
                      _context.next = 13;
                      return fileSize(destFilename);

                    case 13:
                      afterSize = _context.sent;

                      if (!mode) {
                        _context.next = 17;
                        break;
                      }

                      _context.next = 17;
                      return new _promise2.default(function (resolve, reject) {
                        return fs.chmod(destFilename, mode, function (err) {
                          return err ? reject(err) : resolve();
                        });
                      });

                    case 17:
                      results.push({
                        filename: destFilename,
                        changed: beforeSize !== afterSize
                      });

                    case 18:
                    case 'end':
                      return _context.stop();
                  }
                }
              }, _loop, _this);
            });
            _iterator = (0, _getIterator3.default)(src);

          case 17:
            if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
              _context2.next = 22;
              break;
            }

            return _context2.delegateYield(_loop(), 't0', 19);

          case 19:
            _iteratorNormalCompletion = true;
            _context2.next = 17;
            break;

          case 22:
            _context2.next = 28;
            break;

          case 24:
            _context2.prev = 24;
            _context2.t1 = _context2['catch'](14);
            _didIteratorError = true;
            _iteratorError = _context2.t1;

          case 28:
            _context2.prev = 28;
            _context2.prev = 29;

            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }

          case 31:
            _context2.prev = 31;

            if (!_didIteratorError) {
              _context2.next = 34;
              break;
            }

            throw _iteratorError;

          case 34:
            return _context2.finish(31);

          case 35:
            return _context2.finish(28);

          case 36:
            changed = {};

            results.filter(function (result) {
              return result.changed;
            }).forEach(function (result) {
              var filename = result.filename;
              changed[filename] = true;
            });
            return _context2.abrupt('return', changed);

          case 39:
          case 'end':
            return _context2.stop();
        }
      }
    }, _callee, this, [[14, 24, 28, 36], [29,, 31, 35]]);
  }));
}

module.exports = filecopy;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGVjb3B5LmpzIl0sIm5hbWVzIjpbImFyZ3giLCJyZXF1aXJlIiwiZnMiLCJwYXRoIiwiYWdsb2IiLCJta2RpcnBBc3luYyIsImZpbGVTaXplIiwic2luZ2xlQ29weSIsImlzRXhpc3RpbmdEaXIiLCJjbyIsImZpbGVjb3B5Iiwic3JjIiwiZGVzdCIsIm9wdGlvbnMiLCJhcmdzIiwiYXJndW1lbnRzIiwicG9wIiwiRXJyb3IiLCJtb2RlIiwiZGVzdElzRGlyIiwicmVzdWx0cyIsImFTcmMiLCJzcmNGaWxlbmFtZSIsInJlc29sdmUiLCJkZXN0RmlsZW5hbWUiLCJqb2luIiwiYmFzZW5hbWUiLCJta2RpcnAiLCJkaXJuYW1lIiwiYmVmb3JlU2l6ZSIsImFmdGVyU2l6ZSIsInJlamVjdCIsImNobW9kIiwiZXJyIiwicHVzaCIsImZpbGVuYW1lIiwiY2hhbmdlZCIsImZpbHRlciIsInJlc3VsdCIsImZvckVhY2giLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7QUFXQTs7Ozs7Ozs7Ozs7Ozs7OztBQUVBLElBQU1BLE9BQU9DLFFBQVEsTUFBUixDQUFiO0FBQ0EsSUFBTUMsS0FBS0QsUUFBUSxJQUFSLENBQVg7QUFDQSxJQUFNRSxPQUFPRixRQUFRLE1BQVIsQ0FBYjtBQUNBLElBQU1HLFFBQVFILFFBQVEsT0FBUixDQUFkOztlQUN3QkEsUUFBUSxNQUFSLEM7O0lBQWhCSSxXLFlBQUFBLFc7O0FBQ1IsSUFBTUMsV0FBV0wsUUFBUSxvQkFBUixDQUFqQjtBQUNBLElBQU1NLGFBQWFOLFFBQVEsc0JBQVIsQ0FBbkI7QUFDQSxJQUFNTyxnQkFBZ0JQLFFBQVEsMEJBQVIsQ0FBdEI7QUFDQSxJQUFNUSxLQUFLUixRQUFRLElBQVIsQ0FBWDs7QUFFQTtBQUNBLFNBQVNTLFFBQVQsQ0FBbUJDLEdBQW5CLEVBQXdCQyxJQUF4QixFQUE4QkMsT0FBOUIsRUFBdUM7QUFDckMsTUFBSUMsT0FBT2QsS0FBS2UsU0FBTCxDQUFYO0FB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QUFPQyxPQUFQLEdBQWlCL0IsUUFBakIiLCJmaWxlIjoiZmlsZWNvcHkuanMiLCJzb3VyY2VSb290IjoibGliIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5IGZpbGVzLlxuICogQGZ1bmN0aW9uIGZpbGVjb3B5XG4gKiBAcGFyYW0ge3N0cmluZ30gc3JjIC0gU291cmNlIGZpbGUgdG8gY29weSBmcm9tLlxuICogQHBhcmFtIHtzdHJpbmd9IGRlc3QgLSBEZXN0aW5hdGlvbiBmaWxlIHBhdGguXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9uYWwgc2V0dGluZ3MuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLm1rZGlycF0gLSBNYWtlIHBhcmVudCBkaXJlY3RvcnkgaWYgbmVlZGVkLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm1vZGVdIC0gRmlsZSBwZXJtaXNzaW9uLlxuICogQHJldHVybnMge1Byb21pc2V9XG4gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGFyZ3ggPSByZXF1aXJlKCdhcmd4JylcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgYWdsb2IgPSByZXF1aXJlKCdhZ2xvYicpXG5jb25zdCB7IG1rZGlycEFzeW5jIH0gPSByZXF1aXJlKCdhc2ZzJylcbmNvbnN0IGZpbGVTaXplID0gcmVxdWlyZSgnLi9maWxpbmcvZmlsZV9zaXplJylcbmNvbnN0IHNpbmdsZUNvcHkgPSByZXF1aXJlKCcuL2ZpbGluZy9zaW5nbGVfY29weScpXG5jb25zdCBpc0V4aXN0aW5nRGlyID0gcmVxdWlyZSgnLi9maWxpbmcvaXNfZXhpc3RpbmdfZGlyJylcbmNvbnN0IGNvID0gcmVxdWlyZSgnY28nKVxuXG4vKiogQGxlbmRzIGZpbGVjb3B5ICovXG5mdW5jdGlvbiBmaWxlY29weSAoc3JjLCBkZXN0LCBvcHRpb25zKSB7XG4gIGxldCBhcmdzID0gYXJneChhcmd1bWVudHMpXG4gIGlmIChhcmdzLnBvcCgnZnVuY3Rpb24nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2FsbGJhY2sgaXMgbm8gbW9yZSBzdXBwb3J0ZWQuIFVzZSBwcm9taXNlIGludGVyZmFjZS4nKVxuICB9XG4gIG9wdGlvbnMgPSBhcmdzLnBvcCgnb2JqZWN0JykgfHwge31cbiAgZGVzdCA9IGFyZ3MucG9wKCdzdHJpbmcnKVxuXG4gIHJldHVybiBjbyhmdW5jdGlvbiAqICgpIHtcbiAgICBpZiAoIWRlc3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZGVzdCBpcyByZXF1aXJlZC4nKVxuICAgIH1cbiAgICBsZXQgeyBtb2RlIH0gPSBvcHRpb25zXG4gICAgc3JjID0geWllbGQgYWdsb2Ioc3JjKVxuICAgIGxldCBkZXN0SXNEaXIgPSB5aWVsZCBpc0V4aXN0aW5nRGlyKGRlc3QpXG4gICAgbGV0IHJlc3VsdHMgPSBbXVxuICAgIGZvciAobGV0IGFTcmMgb2Ygc3JjKSB7XG4gICAgICBsZXQgc3JjRmlsZW5hbWUgPSBwYXRoLnJlc29sdmUoYVNyYylcbiAgICAgIGxldCBkZXN0RmlsZW5hbWUgPSBkZXN0SXNEaXIgPyBwYXRoLmpvaW4oZGVzdCwgcGF0aC5iYXNlbmFtZShhU3JjKSkgOiBwYXRoLnJlc29sdmUoZGVzdClcbiAgICAgIGlmIChvcHRpb25zLm1rZGlycCkge1xuICAgICAgICB5aWVsZCBta2RpcnBBc3luYyhwYXRoLmRpcm5hbWUoZGVzdEZpbGVuYW1lKSlcbiAgICAgIH1cbiAgICAgIGxldCBiZWZvcmVTaXplID0geWllbGQgZmlsZVNpemUoZGVzdEZpbGVuYW1lKVxuICAgICAgeWllbGQgc2luZ2xlQ29weShzcmNGaWxlbmFtZSwgZGVzdEZpbGVuYW1lKVxuICAgICAgbGV0IGFmdGVyU2l6ZSA9IHlpZWxkIGZpbGVTaXplKGRlc3RGaWxlbmFtZSlcbiAgICAgIGlmIChtb2RlKSB7XG4gICAgICAgIHlpZWxkIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+XG4gICAgICAgICAgZnMuY2htb2QoZGVzdEZpbGVuYW1lLCBtb2RlLCAoZXJyKSA9PlxuICAgICAgICAgICAgZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKClcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgIGZpbGVuYW1lOiBkZXN0RmlsZW5hbWUsXG4gICAgICAgIGNoYW5nZWQ6IGJlZm9yZVNpemUgIT09IGFmdGVyU2l6ZVxuICAgICAgfSlcbiAgICB9XG4gICAgbGV0IGNoYW5nZWQgPSB7fVxuICAgIHJlc3VsdHNcbiAgICAgIC5maWx0ZXIoKHJlc3VsdCkgPT4gcmVzdWx0LmNoYW5nZWQpXG4gICAgICAuZm9yRWFjaCgocmVzdWx0KSA9PiB7XG4gICAgICAgIGxldCBmaWxlbmFtZSA9IHJlc3VsdC5maWxlbmFtZVxuICAgICAgICBjaGFuZ2VkWyBmaWxlbmFtZSBdID0gdHJ1ZVxuICAgICAgfSlcbiAgICByZXR1cm4gY2hhbmdlZFxuICB9KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbGVjb3B5XG4iXX0=